{"version":3,"file":"neuron_b1e62cc9432009ae5566.js","mappings":"kCAiGAA,EAAOC,QA/FP,SAAgBC,GACZC,KAAKC,GAAKC,OAAOC,aAMjBH,KAAKD,KAAeK,MAARL,EAAoC,EAAhBM,KAAKC,SAAe,EAAIP,EAWxDC,KAAKO,SAAW,CACZC,QAAS,CAAC,EACVC,QAAS,CAAC,GAGdT,KAAKU,SAAW,CACZF,QAAS,CAAC,EACVC,QAAS,CAAC,GAMdT,KAAKW,QAILX,KAAKY,OAKLZ,KAAKa,MAELb,KAAKc,QAAU,SAASC,EAAQC,GAC5BhB,KAAKU,SAASF,QAAQO,EAAOd,IAAMc,EACnCA,EAAOR,SAASC,QAAQR,KAAKC,IAAMD,KACnCA,KAAKU,SAASD,QAAQM,EAAOd,IAAMc,EAAOR,SAASE,QAAQT,KAAKC,IAAgBG,MAAVY,EAAsC,EAAhBX,KAAKC,SAAe,EAAIU,CACxH,EAEAhB,KAAKiB,SAAW,SAASC,GACrB,MAAMC,EAAOnB,KAEb,SAASoB,EAAQC,GAAK,OAAO,GAAK,EAAIhB,KAAKiB,KAAKD,GAAI,CAIpD,GAAGH,EACClB,KAAKW,QAAU,EACfX,KAAKY,OAASM,MAGb,CAED,MAAMK,EAAMC,OAAOC,KAAKzB,KAAKO,SAASmB,SAASC,QAAO,SAASC,EAAOC,EAAQC,GAC1E,OAAOF,EAAST,EAAKZ,SAASmB,QAAQG,GAAQjB,OAASO,EAAKZ,SAASE,QAAQoB,EACjF,GAAG7B,KAAKD,MAERC,KAAKW,QAdqBS,EAAZC,EAcUE,IAdgB,EAAIH,EAAQC,IAepDrB,KAAKY,OAASQ,EAAQG,EAC1B,CAhBA,IAAkBF,EAkBlB,OAAOrB,KAAKY,MAChB,EAEAZ,KAAK+B,UAAY,SAASF,EAAQG,EAAK,IACnC,MAAMb,EAAOnB,KAGPuB,EAAgBnB,MAAVyB,EAAsBL,OAAOC,KAAKzB,KAAKU,SAASgB,SAASC,QAAO,SAASC,EAAOC,EAAQC,GAIhG,OAFAX,EAAKT,SAASgB,QAAQG,GAAQtB,SAASE,QAAQU,EAAKlB,IAAMkB,EAAKT,SAASD,QAAQoB,IAAWG,EAAOb,EAAKT,SAASgB,QAAQG,GAAQhB,MAAQM,EAAKP,OAEtIgB,EAAST,EAAKT,SAASgB,QAAQG,GAAQhB,MAAQM,EAAKT,SAASD,QAAQoB,EAChF,GAAG,GAAK7B,KAAKY,OAASiB,EAQtB,OALA7B,KAAKa,MAAQU,EAAMvB,KAAKW,QAGxBX,KAAKD,MAAQiC,EAAOhC,KAAKa,MAElBb,KAAKa,KAChB,EACAoB,QAAQC,IAAIlC,KAChB,C,GC9FImC,EAA2B,CAAC,ECKhC,IDFA,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBjC,IAAjBkC,EACH,OAAOA,EAAaxC,QAGrB,IAAID,EAASsC,EAAyBE,GAAY,CAGjDvC,QAAS,CAAC,GAOX,OAHAyC,EAAoBF,GAAUxC,EAAQA,EAAOC,QAASsC,GAG/CvC,EAAOC,OACf,CClBe,CAAQ,K","sources":["webpack:///./src/pages/neuron/neuron.js","webpack:///webpack/bootstrap","webpack:///./src/pages/neuron/index.js"],"sourcesContent":["\"use strict\";\n\nfunction Neuron(bias) {\n    this.id = crypto.randomUUID();\n    /**\n     * Much like people, each neuron will put a ‚Äúspin‚Äù on the information it receives\n     * (i.e. bias) before processing it and passing it along\n     * @type {number|*}\n     */\n    this.bias = bias == undefined ? Math.random() * 2 - 1 : bias;\n\n    /**\n     * Much like a human organization, neural networks frequently have a ‚Äúhierarchy‚Äù to them;\n     * ‚Äúyou get information from different sources, you weigh the information based on who told you it,\n     * you create your conclusion, and you pass it along to your superiors‚Äù ‚Äî neural networks work almost identically to this.\n     * In these variables we store information regarding which neurons (if any)\n     * a particular neuron listens to, how much they value the ‚Äúincoming‚Äù neuron‚Äôs input,\n     * and which neurons the particular neuron has to forward information to\n     * @type {{weights: {}, neurons: {}}}\n     */\n    this.incoming = {\n        neurons: {}, // new Map()\n        weights: {} // new Map()\n    }\n    // Outgoing Connections\n    this.outgoing = {\n        neurons: {}, // new Map()\n        weights: {} // new Map()\n    }\n    /**\n     * this._output let‚Äôs us know what ‚Äúpercentage‚Äù of the ‚Äúwrongness‚Äù in the previous action\n     * taken was a particular neurons fault for that action\n     */\n    this._output; // f'(x)\n    /**\n     *  this.output gives us the last result (i.e. conclusion) that a particular neuron came to given the last set of inputs.\n     */\n    this.output; // f(x)\n    /**\n     * this.error let‚Äôs us know what ‚Äúpercentage‚Äù of the ‚Äúwrongness‚Äù in the previous actions taken was ‚Äúinternalized‚Äù\n     * by a particular neuron ‚Äî and should be passed on ‚Äúdown the chain‚Äù\n     */\n    this.error; // E'(f(x))\n\n    this.connect = function(neuron, weight) {\n        this.outgoing.neurons[neuron.id] = neuron;\n        neuron.incoming.neurons[this.id] = this;\n        this.outgoing.weights[neuron.id] = neuron.incoming.weights[this.id] = weight == undefined ? Math.random() * 2 - 1 : weight; // weight ‚àà ‚Ñù && -1 < weight < 1\n    }\n\n    this.activate = function(input) {\n        const self = this;\n\n        function sigmoid(x) { return 1 / (1 + Math.exp(-x)) } // f(x) = 1 / (1 + e^(-x))\n        function _sigmoid(x) { return sigmoid(x) * (1 - sigmoid(x)) } // f'(x) = f(x) * (1 - f(x))\n\n        // Input Neurons\n        if(input) {\n            this._output = 1; // f'(x)\n            this.output = input; // f(x)\n        }\n        // Hidden/Output Neurons\n        else {\n            // Œ£ (x ‚Ä¢ w)\n            const sum = Object.keys(this.incoming.targets).reduce(function(total, target, index) {\n                return total += self.incoming.targets[target].output * self.incoming.weights[target];\n            }, this.bias);\n\n            this._output = _sigmoid(sum); // f'(x)\n            this.output = sigmoid(sum); // f(x)\n        }\n\n        return this.output;\n    }\n\n    this.propagate = function(target, rate=0.3) {\n        const self = this;\n\n        //ùõøE /ùõøsquash\n        const sum = target == undefined ? Object.keys(this.outgoing.targets).reduce(function(total, target, index) {\n            // Œîweight\n            self.outgoing.targets[target].incoming.weights[self.id] = self.outgoing.weights[target] -= rate * self.outgoing.targets[target].error * self.output;\n\n            return total += self.outgoing.targets[target].error * self.outgoing.weights[target];\n        }, 0) : this.output - target;\n\n        // ùõøsquash/ùõøsum\n        this.error = sum * this._output\n\n        // Œîbias\n        this.bias -= rate * this.error;\n\n        return this.error;\n    }\n    console.log(this)\n}\n\nmodule.exports = Neuron;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n\n// see https://medium.com/liquid-carrot/creating-a-neural-network-from-scratch-in-javascript-part-1-e469f436442d\n\nconst Neuron = require(\"src/pages/neuron/neuron.js\");\n\nnew Neuron();\n"],"names":["module","exports","bias","this","id","crypto","randomUUID","undefined","Math","random","incoming","neurons","weights","outgoing","_output","output","error","connect","neuron","weight","activate","input","self","sigmoid","x","exp","sum","Object","keys","targets","reduce","total","target","index","propagate","rate","console","log","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}